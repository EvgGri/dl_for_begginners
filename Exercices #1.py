# Types of data
# Все типы данных в Python относятся к одной из 2-х категорий: изменяемые (mutable) и неизменяемые (immutable).
# Неизменяемые объекты:
#   числовые данные (int, float),
#   bool,
#   None,
#   символьные строки (class 'str'),
#   кортежи (tuple).
# Изменяемые объекты:
#   списки (list),
#   множества (set),
#   словари (dict).

# int
# Целочисленный тип переменной в питоне
# Чтобы задать переменную, не нужно указывать ее тип, достаточно присвоить ей значение. При этом тип определится автоматически.
# Давайте попробуем завести переменную, присвоить ей значение -- целое число, и вывести на экран ее значение и тип (type):

x = 5
print(x, '|', type(x))

# float
# Тип переменной для хранения дробных чисел в питоне:

y = 12.345
print(y, '|', type(y))

# С этим типом также можно выполнять арифметические операции (даже целочисленное деление):
a = 4.2 + 5.1
b = 4.2 * 5.1
c = 5.0 / 4.0
d = 5.25 // 4.25
e = 5.25 ** 4.0

print(a, b, c, d, e)

# bool
# Логический тип переменной:
# переменная типа bool может принимать два значения: True и False:

a = True
b = False

print(a, '|', type(a))
print(b, '|', type(b))

# У типа bool существует связь с типом int -- переменная со значением True соответствует int'овой переменной со значением 1, а переменная со значением False -- int'овой переменной со значением 0.
# Давайте в этом убедимся, попробовав сложить значения переменных a и b:
print(a + b)
print(a + a)
print(b + b)

# If
# Условный оператор
# В коде часто приходится проверять выполнимость или невыполнимость каких-то условий. Синтаксис следующий
# if <условие1 (булевское выражение)> :
#     <код, который выполнится, если условие верно>
# elif <условие2 (булевское выражение)>:
#     <код, который выполнится, если условие1 было неверно, а условие2 верно>
# else:
#     <код, который выполнится, если условие1 и условие2 были неверны>
# Обратите внимание, что код, который должен выполняться внутри каждого условия, записывается с отступом в 4 пробела от уровня if, elif и else: в питоне области видимости переменных обозначаются отступами.
# То есть, отступы позволяют понять, где начинается код, который должен выполняться при выполнении условия в if, и где заканчивается
# Рассмотрим пример: пусть в нашем коде есть переменная x. Пусть мы хотим вывести на экран сообщение "x отрицателен", если x<0, "x равен нулю", если x=0 и "x положителен", если x>0. Код будет следующий:

x = 10

if x < 0:
    print("x отрицателен")
elif x == 0:
    print("x равен нулю")
else:
    print("x положителен")

# этот код уже не "внутри" else, потому что записан без отступа в 4 пробела. Поэтому он выполнится
# в любом случае после отработки if-elif-else
print("Done")

if x>3 and x < 11 or x==5:
    print(x)
    # тоже выполнится при выполнения условия после if, так как этот код тоже записан с отступом в 4 пробела
    print("nice")

# if внутри if:
x = 3
y = 5
if x == 3:
    if y > 6:
        # отступ в 4 пробела от внутреннего if
        print("y greater than 6")
    else:
        print("y not grater than 6")

    # отступ в 4 пробела от внешнего if, поэтому код выполнится если x==3 и при любом значении y
    print("x is equal to 3")

# None
# ничего, null
# Специальный тип в питоне, который обозначает ничего
# Его нельзя привести ни к одному другому типу языка. Проверить, является ли переменная param типом None, можно так:
# if param is None
# С первого взгляда может быть непонятно, зачем он нужен, но на самом деле это оченб удобный тип. Например, если вы где-то в коде создаете объект (базу данных, например), обращаясь к внешнему коду и хотите проверить, создалась ли ваша база данных, вы можете осуществить эту проверку, сравнив переменную базы данных с None. Примерно так:
# database = MyDatabase(db_host, db_user, db_password, db_database)
#
# if database is None:
z = None
print(z, '|', type(z))

# Убедимся, что None нельзя привести к другому типу:
# int(z)

# Проверка переменной на None:
if z is None:
    z = 'I am None!'
print(z)